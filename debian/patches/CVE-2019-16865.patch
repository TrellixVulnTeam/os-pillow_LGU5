--- pillow-5.4.1.orig/Tests/test_decompression_bomb.py
+++ pillow-5.4.1/Tests/test_decompression_bomb.py
@@ -15,6 +15,7 @@ class TestDecompressionBomb(PillowTestCa
     def test_no_warning_small_file(self):
         # Implicit assert: no warning.
         # A warning would cause a failure.
+        Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT
         Image.open(TEST_FILE)
 
     def test_no_warning_no_limit(self):
@@ -44,6 +45,14 @@ class TestDecompressionBomb(PillowTestCa
         self.assertRaises(Image.DecompressionBombError,
                           lambda: Image.open(TEST_FILE))
 
+    def test_exception_ico(self):
+        with self.assertRaises(Image.DecompressionBombError):
+            Image.open("Tests/images/decompression_bomb.ico")
+
+    def test_exception_gif(self):
+        with self.assertRaises(Image.DecompressionBombError):
+            Image.open("Tests/images/decompression_bomb.gif")
+
 
 class TestDecompressionCrop(PillowTestCase):
 
--- pillow-5.4.1.orig/Tests/test_file_psd.py
+++ pillow-5.4.1/Tests/test_file_psd.py
@@ -77,6 +77,14 @@ class TestImagePsd(PillowTestCase):
 
         self.assertNotIn("icc_profile", im.info)
 
+    def test_combined_larger_than_size(self):
+        # The 'combined' sizes of the individual parts is larger than the
+        # declared 'size' of the extra data field, resulting in a backwards seek.
+
+        # If we instead take the 'size' of the extra data field as the source of truth,
+        # then the seek can't be negative
+        with self.assertRaises(IOError):
+            Image.open("Tests/images/combined_larger_than_size.psd")
 
 if __name__ == '__main__':
     unittest.main()
--- pillow-5.4.1.orig/Tests/test_file_tiff.py
+++ pillow-5.4.1/Tests/test_file_tiff.py
@@ -541,6 +541,11 @@ class TestFileTiff(PillowTestCase):
             im.load()
             self.assertFalse(fp.closed)
 
+    def test_string_dimension(self):
+        # Assert that an error is raised if one of the dimensions is a string
+        with self.assertRaises(ValueError):
+            Image.open("Tests/images/string_dimension.tiff")
+
 
 @unittest.skipUnless(sys.platform.startswith('win32'), "Windows only")
 class TestFileTiffW32(PillowTestCase):
--- pillow-5.4.1.orig/Tests/test_image.py
+++ pillow-5.4.1/Tests/test_image.py
@@ -532,6 +532,15 @@ class TestImage(PillowTestCase):
         with Image.open(test_file) as im:
             self.assert_warning(None, im.save, temp_file)
 
+    def test_overrun(self):
+        for file in ["fli_overrun.bin", "sgi_overrun.bin", "pcx_overrun.bin"]:
+            im = Image.open(os.path.join("Tests/images", file))
+            try:
+                im.load()
+                self.assertFail()
+            except IOError as e:
+                self.assertEqual(str(e), "buffer overrun when reading image file")
+
 
 class MockEncoder(object):
     pass
--- pillow-5.4.1.orig/Tests/test_imagefile.py
+++ pillow-5.4.1/Tests/test_imagefile.py
@@ -100,6 +100,14 @@ class TestImageFile(PillowTestCase):
             parser = ImageFile.Parser()
             parser.feed(1)
 
+    def test_negative_stride(self):
+        with open("Tests/images/raw_negative_stride.bin", "rb") as f:
+            input = f.read()
+        p = ImageFile.Parser()
+        p.feed(input)
+        with self.assertRaises(IOError):
+            p.close()
+
     def test_truncated_with_errors(self):
         if "zip_encoder" not in codecs:
             self.skipTest("PNG (zlib) encoder not available")
--- pillow-5.4.1.orig/src/PIL/GifImagePlugin.py
+++ pillow-5.4.1/src/PIL/GifImagePlugin.py
@@ -258,6 +258,7 @@ class GifImageFile(ImageFile.ImageFile):
                 self.dispose = None
             elif self.disposal_method == 2:
                 # replace with background colour
+                Image._decompression_bomb_check(self.size)
                 self.dispose = Image.core.fill("P", self.size,
                                                self.info["background"])
             else:
--- pillow-5.4.1.orig/src/PIL/IcoImagePlugin.py
+++ pillow-5.4.1/src/PIL/IcoImagePlugin.py
@@ -167,6 +167,7 @@ class IcoFile(object):
         else:
             # XOR + AND mask bmp frame
             im = BmpImagePlugin.DibImageFile(self.buf)
+            Image._decompression_bomb_check(im.size)
 
             # change tile dimension to only encompass XOR image
             im._size = (im.size[0], int(im.size[1] / 2))
--- pillow-5.4.1.orig/src/PIL/PsdImagePlugin.py
+++ pillow-5.4.1/src/PIL/PsdImagePlugin.py
@@ -209,9 +209,11 @@ def _layerinfo(file):
         # skip over blend flags and extra information
         read(12)  # filler
         name = ""
-        size = i32(read(4))
+        size = i32(read(4))  # length of the extra data field
         combined = 0
         if size:
+            data_end = file.tell() + size
+
             length = i32(read(4))
             if length:
                 file.seek(length - 16, 1)
@@ -229,7 +231,7 @@ def _layerinfo(file):
                 name = read(length).decode('latin-1', 'replace')
             combined += length + 1
 
-        file.seek(size - combined, 1)
+            file.seek(data_end)
         layers.append((name, mode, (x0, y0, x1, y1)))
 
     # get tiles
--- pillow-5.4.1.orig/src/PIL/TiffImagePlugin.py
+++ pillow-5.4.1/src/PIL/TiffImagePlugin.py
@@ -1197,8 +1197,8 @@ class TiffImageFile(ImageFile.ImageFile)
             print("- YCbCr subsampling:", self.tag.get(530))
 
         # size
-        xsize = self.tag_v2.get(IMAGEWIDTH)
-        ysize = self.tag_v2.get(IMAGELENGTH)
+        xsize = int(self.tag_v2.get(IMAGEWIDTH))
+        ysize = int(self.tag_v2.get(IMAGELENGTH))
         self._size = xsize, ysize
 
         if DEBUG:
--- pillow-5.4.1.orig/src/libImaging/FliDecode.c
+++ pillow-5.4.1/src/libImaging/FliDecode.c
@@ -30,7 +30,7 @@ ImagingFliDecode(Imaging im, ImagingCode
 {
     UINT8* ptr;
     int framesize;
-    int c, chunks;
+    int c, chunks, advance;
     int l, lines;
     int i, j, x = 0, y, ymax;
 
@@ -59,10 +59,16 @@ ImagingFliDecode(Imaging im, ImagingCode
 
     chunks = I16(ptr+6);
     ptr += 16;
+    bytes -= 16;
 
     /* Process subchunks */
     for (c = 0; c < chunks; c++) {
-	UINT8 *data = ptr + 6;
+	UINT8* data;
+	if (bytes < 10) {
+	    state->errcode = IMAGING_CODEC_OVERRUN;
+	    return -1;
+	}
+	data = ptr + 6;
 	switch (I16(ptr+4)) {
 	case 4: case 11:
 	    /* FLI COLOR chunk */
@@ -198,7 +204,9 @@ ImagingFliDecode(Imaging im, ImagingCode
 	    state->errcode = IMAGING_CODEC_UNKNOWN;
 	    return -1;
 	}
-	ptr += I32(ptr);
+	advance = I32(ptr);
+	ptr += advance;
+	bytes -= advance;
     }
 
     return -1; /* end of frame */
--- pillow-5.4.1.orig/src/libImaging/PcxDecode.c
+++ pillow-5.4.1/src/libImaging/PcxDecode.c
@@ -22,6 +22,11 @@ ImagingPcxDecode(Imaging im, ImagingCode
     UINT8 n;
     UINT8* ptr;
 
+    if (strcmp(im->mode, "1") == 0 && state->xsize > state->bytes * 8) {
+        state->errcode = IMAGING_CODEC_OVERRUN;
+        return -1;
+    }
+
     ptr = buf;
 
     for (;;) {
--- pillow-5.4.1.orig/src/libImaging/RawDecode.c
+++ pillow-5.4.1/src/libImaging/RawDecode.c
@@ -33,8 +33,15 @@ ImagingRawDecode(Imaging im, ImagingCode
 
 	/* get size of image data and padding */
 	state->bytes = (state->xsize * state->bits + 7) / 8;
-	rawstate->skip = (rawstate->stride) ?
-	    rawstate->stride - state->bytes : 0;
+	if (rawstate->stride) {
+	    rawstate->skip = rawstate->stride - state->bytes;
+	    if (rawstate->skip < 0) {
+	        state->errcode = IMAGING_CODEC_CONFIG;
+	        return -1;
+	    }
+	} else {
+	    rawstate->skip = 0;
+	}
 
 	/* check image orientation */
 	if (state->ystep < 0) {
--- pillow-5.4.1.orig/src/libImaging/SgiRleDecode.c
+++ pillow-5.4.1/src/libImaging/SgiRleDecode.c
@@ -156,6 +156,11 @@ ImagingSgiRleDecode(Imaging im, ImagingC
             c->rlelength = c->lengthtab[c->rowno + c->channo * im->ysize];
             c->rleoffset -= SGI_HEADER_SIZE;
 
+            if (c->rleoffset + c->rlelength > c->bufsize) {
+                state->errcode = IMAGING_CODEC_OVERRUN;
+                return -1;
+            }
+
             /* row decompression */
             if (c->bpc ==1) {
                 if(expandrow(&state->buffer[c->channo], &ptr[c->rleoffset], c->rlelength, im->bands))
